# 触发器

![[Pasted image 20240229154532.png]]



![[Pasted image 20240229154752.png]]



# 锁

1. 全局锁:锁定数据库中的所有表。
2. 表级锁:每次操作锁住整张表。
3. 行级锁:每次操作锁住对应的行数据。


## 全局锁
对于某数据库备份操作`mysqldump`会使得该数据库加上全局锁,导致整个数据库只可查询

在InnoDB引擎中，我们可以在备份时加上参数
--single-transaction 参数来完成不加锁的一致性数据备份。
`mysqldump --single-transaction -uroot -p123456 itcast> itcast.sql`


## 表级锁

### 表锁
分为两类:
1. 表共享读锁(read lock)
2. 表独占写锁(write lock)
语法:
1. 加锁:lock tables 表名... read/write。
2. 释放锁:unlock tables/客户端断开连接。

**读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。**

### 元数据锁
![[Pasted image 20240229162940.png]]

### 意向锁

为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。


1. 意向共享锁(IS):由语句 select...lock in share mode添加。
2. 意向排他锁(IX):由insert、update、delete、select... for update 添加。

- 意向共享锁(IS):与表锁共享锁(read)兼容，与表锁排它锁(write)互斥。
- 意向排他锁(IX):与表锁共享锁(read)及排它锁(write)都互斥。意向锁之间不会互斥


## 行级锁

- 行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。

- InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类:

1. 行锁(Record Lock):锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。
2. 间隙锁(GapLock):锁定索引记录间隙(不含该记录)，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。
3. 临键锁(Next-Key Lock):行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。

`进行各项数据库操作添加的锁(Innodb)`

>![[Pasted image 20240229191203.png]]


`注意`
默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。
1. 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。
2. InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。

用于查看意向锁的加锁情况
```sql
select object_schema,object_name,index_name,lock _type,lock_mode,lock_data from performance_schema.data_locks;

```

### 间隙锁/临键锁

1. 索引上的等值查询(唯一索引)，给不存在的记录加锁时,优化为间隙锁。
2. 索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。
3. 索引上的范围查询(唯一索引)--会访问到不满足条件的第一个值为止。
*间隙锁锁的是间隙而不包含对应的数据记录;
而临键锁既会包含当前的数据记录,也会包含该数据记录之前的间隙*
注意:间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。
