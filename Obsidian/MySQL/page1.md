# 事务



```mysql
select @@autocommit;
set @@autocommit = 0;
```

用于查看事务和设置自动提交的方式,@@autocommit=0->手动提交;

手动提交: commit
手动回滚: rollback
开启事务: start transction / begin
查看建表语句: show create table 表名;


## ACID

- 原子性(Atomicity):事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
- 一致性(Consistency):事务完成时，必须使所有的数据都保持一致状态
- 隔离性(lsolation):数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。
- 持久性(Durability):事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。


## 并发事务问题

- 脏读: 一个事务读到另外一个事务还没有提交的数据。
- 不可重复读: 一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。
- 幻读: 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了幻影”。


>![[Pasted image 20240223133843.png]]


# 体系结构

>![[Pasted image 20240223135358.png]]


# Innodb逻辑存储结构图

>![[Pasted image 20240223141412.png]]

>![[Pasted image 20240223142134.png]]


# 索引

- 索引(index)是帮助MvSQL,高效获取数据的数据结构(有序)。
- 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

### 优点
提高数据检索的效率，降低数据库的I0成本
通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。
### 缺点
索引列也是要占用空间的。
索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。

>![[Pasted image 20240223144401.png]]

## 索引结构

B树

>![[Pasted image 20240223144934.png]]


B+树
>![[Pasted image 20240223150037.png]]

>![[Pasted image 20240223150410.png]]

## hash索引

Hash索引特点:
- Hash索引只能用于对等比较(=，in)，不支持范围查询(between，>，<，...)
- 无法利用索引完成排序操作
- 查询效率高，通常只需要一次检索就可以了，效率通常要高于B+tree索引

存储引擎支持:
- 在MySQL中，支持hash索引的是Memory引擎，而innoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。

## InnoDb与B+树
`为什么InnoDB存储引擎选择使用B+tree索引结构?`
1. 相对于二叉树，层级更少，搜索效率高
2. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低;
3. 相对Hash索引，B+tree支持范围匹配及排序操作;


## 索引分类

>![[Pasted image 20240227140750.png]]

>![[Pasted image 20240227141012.png]]


聚集索引和非聚集索引(二级索引)的区别：

1. 聚集索引中的非叶子节点存储的是表的主键，非聚集索引的非叶子节点存储的是自己设置的索引字段对应的值(如果是联合索引，那就是联合索引的几个字段对应的值)

2. 聚集索引的叶子节点，存储着当前表中每条记录的所有信息；非聚集索引的叶子节点，只存储当前记录对应的主键ID(也就是聚集索引的非叶子节点存储的值)

>![[Pasted image 20240227141814.png]]


>![[Pasted image 20240227142514.png]]


其中n为记录条数,n+1为指针数,每页固定内存16K.



