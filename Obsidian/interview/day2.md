## 对线程安全的理解

![[Pasted image 20240425165710.png]]



## 守护线程的作用

![[Pasted image 20240425170539.png]]



## ThreadLocal的原理及使用场景



![[Pasted image 20240425171231.png]]


![[Pasted image 20240425171330.png]]



## ThreadLocal的内存泄漏问题

![[Pasted image 20240425185242.png]]

图中虚线表示弱引用,实线表示强引用.
![[Pasted image 20240425185513.png]]


![[Pasted image 20240425185214.png]]


## 并发、并行、串行的区别

- 串行: 在时间上不可能发生重叠，前一个任务没搞定，下一个任务就只能等着
- 并行: 在时间上是重叠的，两个任务在同一时刻互不干扰的同时执行。
- 并发: 允许两个任务彼此干扰。统一时间点、只有一个任务运行，交替执行

## 并发三大特性


并发的三大特性包括原子性、可见性和有序性。
1. 原子性：原子性指的是一个或多个操作，要不全部执行且不被打断，要不就全部不执行。在并发环境中，多个线程可能同时访问和修改共享数据，因此确保操作的原子性至关重要。通过使用某些同步机制（如synchronized关键字、Lock或CAS），可以确保操作的原子性，从而防止数据不一致或其他并发问题。
2. 可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到这个修改的值。由于现代计算机系统中的缓存机制，一个线程对共享变量的修改可能不会立即对其他线程可见。为了确保可见性，可以使用volatile关键字、内存屏障、synchronized关键字或Lock等机制来确保线程间的数据共享和一致性。
3. 有序性：有序性是指程序执行的时候按照代码的先后顺序进行。然而，由于JVM中存在指令重排优化，代码的执行顺序可能会受到影响。虽然这种优化可以提高程序的性能，但在并发环境中可能导致线程安全问题。为了保证有序性，同样可以使用volatile关键字、内存屏障、synchronized关键字或Lock等机制来防止指令重排带来的问题。


## 为什么用线程池?解释下线程池参数?
1. 降低资源消耗;提高线程利用率，降低创建和销毁线程的消耗。
2. 高响应速度;任务来了，直接有线程可用可执行，而不是先创建线程，再执行。
3. 提高线程的可管理性;线程是稀缺资源，使用线程池可以统一分配调优监控。

![[Pasted image 20240425193450.png]]



## 线程池中阻塞队列的作用?为什么是先添加列队而不是先创建最大线程?

1. 一般的队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留当前的任务了，阻塞队列通过阻塞可以保留住当前想要继续入队的任务。阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源.。阻塞队列自带阻塞和唤醒的功能，不需要额外处理，无任务执行时,线程池利用阻塞队列的take方法挂起，从而维持核心线程的存活、不至于一直占用cpu资源


2. 在创建新线程的时候，是要获取全局锁的，这个时候其它的线程就得阻塞，影响了整体效率。

## 线程池中线程复用原理

线程池将线程和任务进行解耦，线程是线程，任务是任务，摆脱了之前通过Thread 创建线程时的一个线程必须对应一个任务的限制。
在线程池中，同一个线程可以从阻塞队列中不断获取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中不停检查是否有任务需要被执行，如果有则直接执行，也就是调用任务中的 run 方法，将 run 方法当成一个普通的方法执行，通过这种方式只使用固定的线程就将所有任务的 run 方法串联起来。


